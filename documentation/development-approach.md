Outside environmental values
============================
 * TIMEZONE: Need to set the timezone for the container to process in. This is important for scheduling purposes.
 * BACKUP_METHOD : Type of backup. Either SINGLE meaning we are just backing up the db within the stack or STANDALONE where it is a backup facility for multiple database connections.
                    The program upon start up will need to determine if it is in SINGLE MODE. If so, transpose the connection information into the database and use the same container name as the connection name.
                    Default is SINGLE as I expect most people will use this container as a sidecar with their mariadb container.
 * BACKUP_LOCATION : This is not a environmental value as more than an volume map.
 

Backup Directory Structure
==========================
* The backup directory root will be provided as a environment variable passed through the container.
* Volumes will be mounted to it from docker compose files.
* We are going to use a [DATABASE]/[SCHEDNAME]/[BACKUP_DATE] structure. This allows multiple backup schedules for a database while retaining the backups within the folder

Example : If I have a database called GL and I need to back it up daily and on the first day of the month, this is how the folder structure would look like
/backup/GL/DAILY/2021.07.16
/backup/GL/DAILY/2021.07.17
/backup/GL/DAILY/2021.07.18
/backup/GL/MONTHEND/2021.07.31
/backup/GL/MONTHEND/2021.08.31
/backup/GL/MONTHEND/2021.09.30

Process:

1. Create the target directory using today's data
    eg : /backup/2021.07.16

2. Pull a list of the databases from the management database.
    select db_id, db_name, db_username, db_password, db_port, db_host, db_protocol from db_list where active_yn = 'Y';

3. iterate through the db_list results and execute the mysqldump calls
    3.1 Create the arg list
        --user={s_db_username}
        --password={s_db_password}
        --host={s_db_host}
        --protocol={s_db_protocol}
        --database={s_db_name}
    3.2 Create target file name for gzip
        s_target_filename = {s_db_name}+"_"+{s_timestamp}+".sql.gz"

    3.3 Execute the command via subprocess.run() send the output the /dev/null

    3.4 evaluate the return object's return code to see if the process was successful:
        3.4.1 If the process was succesfull, record it in the database
                insert into bkup_log (db_id, bkup_dt, db_backup_file_loc, db_file_size, status_id)
        3.4.2 If the process had an error, record it in the database and send an alert
                insert into bkup_log (db_id, bkup_dt, db_backup_file_loc, db_file_size, status_id, error_log)
                send alert (email) indicating the process failed.

Database Design
===============

Tables:

DB_LIST
-------
 - PURPOSE : This will list all the databases that need to be backed up. This table will contain all the connection information so that the program can connect to local or remote databases (or both)
 - FIELDS:
    DB_ID [PK] : Primary Key
    CONNECTION_ID [FK] : Foreign key (Links to DB_CONNECTIONS.CONNECTION_ID)
    NAME : Friendly name of this record. This is to allow backing up the database on
    DB_NAME : Database name    
    ACTIVE_YN : Active/Inactive Flag. a "Y" means the Database is active and is available for backup. a "N" means the database is inactive and will not show up on the screens.
    

DB_CONNECTIONS
--------------
 - PURPOSE: This will contain all the database sources (eg connections) that can be used for database backup + restore operations.
 - FIELDS: 
    CONNECTION_ID [PK] : Primary Key
    NAME : User-Friendly name of the connection. used in the User Interface.
    SVR_HOST : Database Server where the database is hosted. 
    SVR_PORT : TCI/IP Port of the database Server
    SVR_PROTOCOL : Protocol Type of the database server. Most of the time it will be TCP/IP
    CONN_USERNAME : User ID that will perform the database backup
    CONN_PASSWORD : Password of the User ID. We will encrypt this internally with a hash
    ACTIVE_YN : Active/Inactive Flag. a "Y" means the Connection is visible in the UI. A "N" means the Connection is inactive and will not show up in the active portions of the UI.


DB_SCHEDULE
-----------
 - PURPOSE : This will retain the backup schedules of the databases. The program will use this table to populate the crontab entries required.
 - FIELDS : 
    SCHD_ID [PK] : Primary Key
    DB_ID [FK] : Foriegn Key (Links to DB_LIST.DB_ID)
    NAME : Name of the Schedule. This is for simplifying the schedules for readability.
    DIR_NAME : The Internal Directory name that will be used by the program. This will be generated by stripping out all the special characters and spaces from SCHD_NAME
    SCHD_MIN : Value for the "Min" column on the crontab file
    SCHD_HOUR : Value for the "Hour" column on the crontab file
    SCHD_DAY : Value for the "Day" column on the crontab file
    SCHD_MONTH : Value for the "Month" column on the crontab file
    SCHD_WKYDY : Value of the "Weekday" column on the crontab file. Weekdays start with 1 (Sunday) through 7 (Saturday)
    ACTIVE_YN : Active/Inactive Flag. A "Y" means the schedule is active on crontab. a "N" means the schedule in inactive and removed from crontab.
    RETAIN_PRIOR_BKCP_CNT : Number of prior backups we should retain. The program will use a FIFO method to roll the backups using this as the number to keep.

BCKP_LOG
--------
 - PURPOSE : This table will record all backup operations perfromed by this program.
 - FIELDS : 
    BCKP_LOG_ID [PK] : Primary Key
    DB_ID [FK] : Foreign Key (Links to DB_LIST.DB_ID)
    STRT_DT : Start date/time of the backup operation
    END_DT : End date/time of the backup operation
    BCKP_FILE_LOC : Path (relative to backup location) of the backup file that was created by the program.
    BCKP_FILE_SIZE : Size in Megabytes of the final backup file. Helpful to show the growth of backups over time
    BCKP_STATUS : Final status of the backup operation. Valid values are [IN-PROGRESS, COMPLETED, ERROR, PURGED]

APP_USRS
--------
 - PURPOSE : This table holds the users of the application
 - FIELDS :
    USR_ID [PK] : Primary Key.
    USR_NAME : Full Name of the user.
    USR_NICKNAME : Nick Name of the user. This will be the name shown on all the screens.
    USR_PWD : User Password. This will be encrpyted by the application.
    USR_EMAIL_ADR : Email Address of the User.
    USR_ROLE : User Role. Valid values are [REGULAR, ADMIN].
    ACTIVE_YN : Active/Inactive Flag. A "Y" indicates the user is active. a "N" indicates the user is disabled.

APP_SYS_SETTINGS
----------------
 - PURPOSE : This holds application-wide settings that will be referenced from both the program and the web app. These are user-editable.
 - FIELDS : 
    SYS_SETTING_ID [PK] : Primary Key
    CATEGORY_NM : System Category Name
    SETTING_NM : System setting Name
    SETTING_VAL : Setting Value
    LST_UPDT_DT : Last Value Update Date/Time 








-------



Scheduling
==========
* I am going to use Alpine Linux's crontab functionality to handle all database backups
* Reference link: https://devopsheaven.com/cron/docker/alpine/linux/2017/10/30/run-cron-docker-alpine.html
